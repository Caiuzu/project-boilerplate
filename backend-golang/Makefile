# Makefile para o projeto Go backend-golang

# --- Configura√ß√µes ---
# Nome do bin√°rio da aplica√ß√£o
APP_NAME=hackathon_app
# Diret√≥rio do main.go
CMD_DIR=./cmd/server
# Diret√≥rio de sa√≠da do bin√°rio
OUTPUT_DIR=./bin

# Vari√°veis para Docker Compose
COMPOSE_FILE=docker-compose.yml
POSTGRES_VOLUME_NAME=postgres_data # Nome do volume definido no docker-compose.yml

# Vari√°veis para Migrations
# Certifique-se de que DATABASE_URL est√° no seu .env ou exportado no ambiente
# Exemplo: DATABASE_URL="postgres://postgres:postgres@localhost:5432/hackathondb?sslmode=disable"
MIGRATIONS_PATH=internal/database/migrations
MIGRATIONS_SOURCE_URL=file://$(MIGRATIONS_PATH)

# Vari√°veis para Swag (Swagger)
SWAG_CMD_DIR_ARG=cmd/server/main.go
SWAG_OUTPUT_DIR="./docs"
# Determina o caminho para o execut√°vel swag
SWAG_BIN_DIR := $(shell go env GOBIN)
ifeq ($(SWAG_BIN_DIR),)
    SWAG_BIN_DIR := $(shell go env GOPATH)/bin
endif
SWAG_CMD := $(SWAG_BIN_DIR)/swag

# Cores para output (opcional)
GREEN  := $(shell tput -Txterm setaf 2)
YELLOW := $(shell tput -Txterm setaf 3)
CYAN   := $(shell tput -Txterm setaf 6)
RESET  := $(shell tput -Txterm sgr0)


# --- Alvos Principais --- 
.PHONY: all run build clean tidy test swagger migrate migrate-up migrate-down migrate-create db-start db-stop db-restart db-logs dev-start db-recreate rebuild redis-cli redis-monitor

all: build

# Comando principal para desenvolvimento: garante depend√™ncias, swagger, build e roda a app
dev-start: db-start tidy swagger build
	@echo "$(CYAN)üöÄ Iniciando a aplica√ß√£o $(APP_NAME)...$(RESET)"
	@$(OUTPUT_DIR)/$(APP_NAME)

run: dev-start # Alias para dev-start para manter compatibilidade ou prefer√™ncia

# Alvo para reconstruir tudo do zero (clean + tidy + swagger + build)
rebuild: clean tidy swagger build
	@echo "$(GREEN)‚úÖ Reconstru√ß√£o completa conclu√≠da!$(RESET)"

build: # Constr√≥i o bin√°rio da aplica√ß√£o
	@echo "$(YELLOW)üöß Construindo o bin√°rio da aplica√ß√£o...$(RESET)"
	@mkdir -p $(OUTPUT_DIR)
	@go build -o $(OUTPUT_DIR)/$(APP_NAME) $(CMD_DIR)/main.go
	@echo "$(GREEN)‚úÖ Bin√°rio constru√≠do em $(OUTPUT_DIR)/$(APP_NAME)$(RESET)"

clean: # Limpa bin√°rios e arquivos tempor√°rios
	@echo "$(YELLOW)üßπ Limpando arquivos de build...$(RESET)"
	@rm -rf $(OUTPUT_DIR)
	@rm -rf $(SWAG_OUTPUT_DIR) # Limpa docs do Swagger tamb√©m
	@echo "$(GREEN)‚úÖ Limpeza conclu√≠da.$(RESET)"

tidy: # Garante que o go.mod e go.sum est√£o corretos e baixa depend√™ncias
	@echo "$(YELLOW)üßπ Organizando e baixando depend√™ncias Go (go mod tidy && go mod download)...$(RESET)"
	@go mod tidy
	@go mod download
	@echo "$(GREEN)‚úÖ Depend√™ncias Go organizadas e baixadas.$(RESET)"

test: tidy # Roda os testes (precisa de arquivos _test.go)
	@echo "$(YELLOW)üß™ Rodando testes...$(RESET)"
	@go test ./... -v

swagger: # Gera a documenta√ß√£o Swagger
	@echo "$(YELLOW)üìö Gerando documenta√ß√£o Swagger...$(RESET)"
	@echo "$(YELLOW)Usando comando swag em: $(SWAG_CMD)$(RESET)"
	@if ! test -x "$(SWAG_CMD)"; then \
		echo "$(YELLOW)CLI 'swag' n√£o encontrado ou n√£o execut√°vel em $(SWAG_CMD). Tentando instalar...$(RESET)"; \
		go install github.com/swaggo/swag/cmd/swag@latest; \
		if ! test -x "$(SWAG_CMD)"; then \
			echo "$(YELLOW)Falha ao instalar ou encontrar 'swag' em $(SWAG_CMD) ap√≥s a instala√ß√£o.$(RESET)"; \
			echo "$(YELLOW)Verifique seu GOPATH/GOBIN e PATH, ou se a instala√ß√£o do 'swag' teve sucesso.$(RESET)"; \
			exit 1; \
		fi; \
	fi
	@echo "$(YELLOW)Executando: $(SWAG_CMD) init -g $(SWAG_CMD_DIR_ARG) --output $(SWAG_OUTPUT_DIR) --parseDependency --parseInternal$(RESET)"
	@"$(SWAG_CMD)" init -g $(SWAG_CMD_DIR_ARG) --output $(SWAG_OUTPUT_DIR) --parseDependency --parseInternal
	@echo "$(GREEN)‚úÖ Documenta√ß√£o Swagger gerada em $(SWAG_OUTPUT_DIR)$(RESET)"


# --- Alvos do Banco de Dados (Docker Compose) --- 
db-start: # Inicia o container do PostgreSQL se n√£o estiver rodando
	@echo "$(YELLOW)üê≥ Verificando e iniciando container do PostgreSQL...$(RESET)"
	@docker-compose -f $(COMPOSE_FILE) up -d postgres
	@echo "$(GREEN)‚úÖ Container do PostgreSQL pronto ou j√° estava rodando.$(RESET)"
	@echo "$(YELLOW)üïí Aguardando o banco de dados ficar completamente acess√≠vel...$(RESET)"
	@# Loop simples para esperar o Postgres aceitar conex√µes (melhorar se necess√°rio)
	@timeout=30; \
	while ! docker exec hackathon_postgres pg_isready -U $${DB_USER:-postgres} -d $${DB_NAME:-hackathondb} -q && [ $$timeout -gt 0 ]; do \
	  sleep 1; \
	  timeout=$$((timeout-1)); \
	done; \
	if [ $$timeout -eq 0 ]; then \
	  echo "$(YELLOW)‚ö†Ô∏è  Timeout esperando pelo PostgreSQL.$(RESET)"; \
	else \
	  echo "$(GREEN)üêò PostgreSQL pronto para conex√µes.$(RESET)"; \
	fi

db-stop: # Para o container do PostgreSQL
	@echo "$(YELLOW)üê≥ Parando container do PostgreSQL...$(RESET)"
	@docker-compose -f $(COMPOSE_FILE) down
	@echo "$(GREEN)‚úÖ Container do PostgreSQL parado.$(RESET)"

db-restart: db-stop db-start # Reinicia o container do PostgreSQL

db-logs: # Mostra os logs do container do PostgreSQL
	@echo "$(YELLOW)üìú Logs do PostgreSQL:$(RESET)"
	@docker-compose -f $(COMPOSE_FILE) logs -f postgres

db-recreate: # Para, remove o volume de dados, inicia e aplica migra√ß√µes
	@echo "$(YELLOW)‚ö†Ô∏è  Recriando o banco de dados! Todos os dados ser√£o perdidos. $(RESET)"
	$(MAKE) db-stop
	@echo "$(YELLOW)üóëÔ∏è Removendo volume de dados do PostgreSQL ($(POSTGRES_VOLUME_NAME))...$(RESET)"
	@docker volume rm $(POSTGRES_VOLUME_NAME) || true # O '|| true' evita erro se o volume n√£o existir
	$(MAKE) db-start
	$(MAKE) migrate-up
	@echo "$(GREEN)‚úÖ Banco de dados recriado e migra√ß√µes aplicadas.$(RESET)"


# --- Alvos de Migrations (golang-migrate/migrate) --- 
# √â necess√°rio ter o migrate CLI instalado: https://github.com/golang-migrate/migrate/tree/master/cmd/migrate
# Ou rodar via Docker: https://github.com/golang-migrate/migrate/pkgs/container/migrate
# Makefile tentar√° instalar se n√£o encontrar.

ensure-migrate-cli:
	@command -v migrate >/dev/null 2>&1 || (echo "$(YELLOW)CLI 'migrate' n√£o encontrado. Tentando instalar...$(RESET)"; go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest; echo "$(GREEN)Tente rodar o comando make novamente.$(RESET)"; exit 1)

migrate-status: ensure-migrate-cli db-start # Mostra o status das migrations
	@echo "$(YELLOW)üìä Verificando status das migra√ß√µes...$(RESET)"
	@migrate -source $(MIGRATIONS_SOURCE_URL) -database "$$(grep DATABASE_URL .env | cut -d '=' -f2- | tr -d '\"')" version

migrate: ensure-migrate-cli db-start migrate-up # Alias para migrate-up

migrate-up: ensure-migrate-cli db-start # Aplica todas as migra√ß√µes 'up' pendentes
	@echo "$(YELLOW)‚¨ÜÔ∏è  Aplicando migra√ß√µes 'up'...$(RESET)"
	@migrate -source $(MIGRATIONS_SOURCE_URL) -database "$$(grep DATABASE_URL .env | cut -d '=' -f2- | tr -d '\"')" up
	@echo "$(GREEN)‚úÖ Migra√ß√µes 'up' aplicadas.$(RESET)"

migrate-down: ensure-migrate-cli db-start # Reverte a √∫ltima migra√ß√£o 'up' aplicada
	@echo "$(YELLOW)‚¨áÔ∏è  Revertendo √∫ltima migra√ß√£o 'down'...$(RESET)"
	@migrate -source $(MIGRATIONS_SOURCE_URL) -database "$$(grep DATABASE_URL .env | cut -d '=' -f2- | tr -d '\"')" down 1
	@echo "$(GREEN)‚úÖ √öltima migra√ß√£o revertida.$(RESET)"

migrate-down-all: ensure-migrate-cli db-start # Reverte TODAS as migra√ß√µes
	@echo "$(YELLOW)‚¨áÔ∏è‚¨áÔ∏è Revertendo TODAS as migra√ß√µes 'down'...$(RESET)"
	@migrate -source $(MIGRATIONS_SOURCE_URL) -database "$$(grep DATABASE_URL .env | cut -d '=' -f2- | tr -d '\"')" down -all
	@echo "$(GREEN)‚úÖ Todas as migra√ß√µes revertidas.$(RESET)"

migrate-force: ensure-migrate-cli db-start # For√ßa uma vers√£o espec√≠fica da migra√ß√£o (CUIDADO!)
	@echo "$(YELLOW)‚ùóÔ∏è For√ßando vers√£o da migra√ß√£o (ex: para resolver estado 'dirty'). Use com CUIDADO! $(RESET)"
	@echo "$(YELLOW)Por favor, informe a vers√£o para for√ßar: $(RESET)"
	@read version; \
	migrate -source $(MIGRATIONS_SOURCE_URL) -database "$$(grep DATABASE_URL .env | cut -d '=' -f2- | tr -d '\"')" force $$version
	@echo "$(GREEN)‚úÖ Vers√£o for√ßada para $$version.$(RESET)"

# Para usar: make migrate-create NAME=nome_da_sua_migration
migrate-create: ensure-migrate-cli # Cria novos arquivos de migra√ß√£o (up e down)
	@if [ -z "$(NAME)" ]; then \
		echo "$(YELLOW)‚ùóÔ∏è Por favor, especifique o nome da migra√ß√£o. Uso: make migrate-create NAME=<nome_da_migration>$(RESET)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)‚ú® Criando novos arquivos de migra√ß√£o para: $(NAME)...$(RESET)"
	@migrate create -ext sql -dir $(MIGRATIONS_PATH) -seq $(NAME)
	@echo "$(GREEN)‚úÖ Arquivos de migra√ß√£o criados em $(MIGRATIONS_PATH)$(RESET)"


# --- Ajuda --- 
help: # Mostra esta mensagem de ajuda
	@echo "-------------------------------------------------------------------------"
	@echo "$(GREEN)Makefile para o Projeto Go - Hackathon Backend$(RESET)"
	@echo "-------------------------------------------------------------------------"
	@echo "Uso: make [alvo]"
	@echo ""
	@echo "Alvos Principais para Desenvolvimento:"
	@echo "  $(CYAN)dev-start (ou run)$(RESET)   Inicia DB, garante depend√™ncias, gera Swagger, constr√≥i e roda a app."
	@echo "  $(YELLOW)rebuild$(RESET)            Limpa tudo e reconstr√≥i (clean + tidy + swagger + build)."
	@echo "  $(YELLOW)build$(RESET)              Constr√≥i o bin√°rio da aplica√ß√£o."
	@echo "  $(YELLOW)tidy$(RESET)                Organiza depend√™ncias Go (go mod tidy & download)."
	@echo "  $(YELLOW)swagger$(RESET)            Gera a documenta√ß√£o Swagger."
	@echo "  $(YELLOW)test$(RESET)               Roda os testes (requer arquivos _test.go)."
	@echo "  $(YELLOW)clean$(RESET)              Remove arquivos de build e docs do Swagger."
	@echo ""
	@echo "Alvos do Banco de Dados (Docker Compose):"
	@echo "  $(YELLOW)db-start$(RESET)           Inicia o container do PostgreSQL."
	@echo "  $(YELLOW)db-stop$(RESET)            Para o container do PostgreSQL."
	@echo "  $(YELLOW)db-restart$(RESET)         Reinicia o container do PostgreSQL."
	@echo "  $(YELLOW)db-logs$(RESET)            Mostra os logs do container PostgreSQL."
	@echo "  $(YELLOW)db-recreate$(RESET)        ‚ö†Ô∏è  PARA, LIMPA DADOS, inicia DB e aplica migra√ß√µes."
	@echo ""
	@echo "Alvos de Migrations (golang-migrate/migrate):"
	@echo "  $(YELLOW)migrate-status$(RESET)      Mostra o status atual das migra√ß√µes."
	@echo "  $(YELLOW)migrate (ou migrate-up)$(RESET) Aplica todas as migra√ß√µes 'up' pendentes."
	@echo "  $(YELLOW)migrate-down$(RESET)        Reverte a √∫ltima migra√ß√£o aplicada."
	@echo "  $(YELLOW)migrate-down-all$(RESET)    Reverte TODAS as migra√ß√µes."
	@echo "  $(YELLOW)migrate-force VERSION=<num>$(RESET) For√ßa uma vers√£o espec√≠fica da migra√ß√£o (use com cuidado)."
	@echo "  $(YELLOW)migrate-create NAME=<nome>$(RESET) Cria novos arquivos de migra√ß√£o."
	@echo ""
	@echo "Outros Alvos:"
	@echo "  $(YELLOW)help$(RESET)               Mostra esta mensagem de ajuda."
	@echo "-------------------------------------------------------------------------"

.DEFAULT_GOAL := help

# Vari√°veis
BINARY_NAME=hackathon_app
MAIN_FILE=cmd/server/main.go
SWAG_CMD_DIR_ARG=cmd/server/main.go
OUTPUT_DIR=./bin
GOPATH=$(shell go env GOPATH)

# Comandos
.PHONY: all build clean test run dev-start dev-stop swagger rebuild redis-cli redis-monitor tidy migrate

all: clean build

build:
	@echo "Construindo o bin√°rio..."
	@mkdir -p $(OUTPUT_DIR)
	go build -o $(OUTPUT_DIR)/$(BINARY_NAME) $(MAIN_FILE)

clean:
	@echo "Limpando arquivos gerados..."
	rm -f $(OUTPUT_DIR)/$(BINARY_NAME)
	rm -rf docs

tidy:
	@echo "Organizando e baixando depend√™ncias Go..."
	go mod tidy
	go mod download

test:
	@echo "Executando testes..."
	go test -v ./...

run: build
	@echo "Executando a aplica√ß√£o..."
	$(OUTPUT_DIR)/$(BINARY_NAME)

dev-start:
	@echo "Iniciando ambiente de desenvolvimento..."
	docker-compose up -d
	@echo "Aguardando servi√ßos iniciarem..."
	sleep 5
	@echo "Iniciando aplica√ß√£o..."
	go run $(MAIN_FILE)

dev-stop:
	@echo "Parando ambiente de desenvolvimento..."
	docker-compose down

swagger:
	@echo "Verificando se swag est√° instalado..."
	@if ! command -v swag > /dev/null; then \
		echo "Instalando swag..."; \
		go install github.com/swaggo/swag/cmd/swag@latest; \
	fi
	@echo "Gerando documenta√ß√£o Swagger..."
	@if command -v swag > /dev/null; then \
		swag init -g $(SWAG_CMD_DIR_ARG) -o docs; \
	else \
		$(GOPATH)/bin/swag init -g $(SWAG_CMD_DIR_ARG) -o docs; \
	fi

rebuild: clean tidy swagger build

redis-cli:
	@echo "Conectando ao Redis CLI..."
	docker exec -it hktn-redis redis-cli

redis-monitor:
	@echo "Monitorando Redis..."
	docker exec -it hktn-redis redis-cli monitor

migrate:
	@echo "Executando migra√ß√µes..."
	go run $(MAIN_FILE) migrate
